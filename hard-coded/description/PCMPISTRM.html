<p>The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1, "Imm8 Control Byte Operation for PCMPESTRI /PCMPESTRM / PCMPISTRI / PCMPISTRM") generating a mask stored to XMM0.</p>
<p>Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)</p>
<p>The comparison and aggregation operation are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is theneither stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.</p>
<p>Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:</p>
<ul>
<li>CFlag - Reset if IntRes2 is equal to zero, set otherwise</li>
<li>ZFlag - Set if any byte/word of xmm2/mem128 is null, reset otherwise</li>
<li>SFlag - Set if any byte/word of xmm1 is null, reset otherwise</li>
<li>OFlag - IntRes2[0]</li>
<li>AFlag - Reset</li>
<li>PFlag - Reset</li>
</ul>
<table>
  <caption>Effective Operand Size</caption>
<tr>
<th>Operating mode/size</th>
<th>Operand1</th>
<th>Operand 2</th>
<th>Result</th>
</tr>
<tr>
<td>16 bit</td>
<td>xmm</td>
<td>xmm/m128</td>
<td>XMM0</td>
</tr>
<tr>
<td>32 bit</td>
<td>xmm</td>
<td>xmm/m128</td>
<td>XMM0</td>
</tr>
<tr>
<td>64 bit</td>
<td>xmm</td>
<td>xmm/m128</td>
<td>XMM0</td>
</tr>
<tr>
<td>64 bit + REX.W</td>
<td>xmm</td>
<td>xmm/m128</td>
<td>XMM0</td>
</tr>
</table>
