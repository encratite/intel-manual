<p>Performs a full or partial save of the enabled processor state components to a memory address specified in the destination operand. A full or partial save of the processor states is specified by an implicit mask operand via the register pair, EDX:EAX. The destination operand is a memory location that must be 64-byte aligned.</p>
<p>The implicit 64-bit mask operand in EDX:EAX specifies the subset of enabled processor state components to save into the XSAVE/XRSTOR save area. The XSAVE/XRSTOR save area comprises of individual save area for each processor state components and a header section, see Table 4-18. Each component save area iswritten if both the corresponding bits in the save mask operand and in the XFEATURE_ENABLED_MASK (XCR0) register are 1. A processor state component save area is not updated if either one of the corresponding bits in the mask operand or the XFEATURE_ENABLED_MASK register is 0. If the mask operand (EDX:EAX) contains all 1's, all enabled processor state components in XFEATURE_ENABLED_MASK is written to the respective component save area.</p>
<p>The bit assignment used for the EDX:EAX register pair matches the XFEATURE_ENABLED_MASK register (see chapter 2 of Vol. 3B). For the XSAVE instruction, software can specify "1" in any bit position of EDX:EAX, irrespective of whether the corresponding bit position in XFEATURE_ENABLED_MASK is valid for the processor. The bit vector in EDX:EAX is "anded" with the XFEATURE_ENABLED_MASK to determine which save area will be written.</p>
<p>The content layout of the XSAVE/XRSTOR save area is architecturally defined to be extendable and enumerated via the sub-leaves of CPUID.0DH leaf. The extendable framework of the XSAVE/XRSTOR layout is depicted by Table 4-18. The layout of theXSAVE/XRSTOR save area is fixed and may contain non-contiguous individual save areas. The XSAVE/XRSTOR save area is not compacted if some features are not saved or are not supported by the processor and/or by system software.</p>
<p>The layout of the register fields of first 512 bytes of the XSAVE/XRSTOR is the same as the FXSAVE/FXRSTOR area (refer to "FXSAVE—Save x87 FPU, MMX Technology,and SSE State" on page 476). But XSAVE/XRSTOR organizes the 512 byte area asx87 FPU states (including FPU operation states, x87/MMX data registers), MXCSR (including MXCSR_MASK), and XMM registers.</p>
<p>Bytes 464:511 are available for software use. The processor does not write to bytes</p>
<p>464:511 when executing XSAVE.</p>
<p>The processor writes 1 or 0 to each HEADER.XSTATE_BV[i] bit field of an enabled processor state component in a manner that is consistent to XRSTOR's interaction with HEADER.XSTATE_BV (see the operation section of XRSTOR instruction). If a processor implementation discern that a processor state component is in its initialized state (according to Table 4-20) it may modify the corresponding bit in theHEADER.XSTATE_BV as ‘0'.</p>
<p>A destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) will result in a general-protection (#GP) exception being generated. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</p>