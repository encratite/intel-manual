<p>The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction operates the same in non-64-bit modes and 64-bit mode.</p>
<p>CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers. On Intel 64 processors, CPUID clears the high 32 bits of the RAX/RBX/RCX/RDX registers in all modes. The instruction&apos;s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well). For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers:</p>
<pre>MOV EAX, 00H
  CPUID</pre>
<p>"Information Returned by CPUID Instruction" shows information returned, depending on the initial value loaded into the EAX register. Table 3-13 shows the maximum CPUID input value recognized for eachfamily of IA-32 processors on which CPUID is implemented.</p>
<p>Two types of information are returned: basic and extended function information. If a value entered for CPUID.EAX is higher than the maximum input value for basic or extended function for that processor then the data for the highest basic information leaf is returned. For example, using the Intel Core i7 processor, the following is true:</p>
<pre>CPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *)
  CPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *)
  CPUID.EAX = 0BH (* Returns Extended Topology Enumeration leaf. *)
  CPUID.EAX = 0CH (* INVALID: Returns the same information as CPUID.EAX = 0BH. *)
  CPUID.EAX = 80000008H (* Returns linear/physical address size data. *)
  CPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX = 0BH. *)
</pre>
<p>If a value entered for CPUID.EAX is less than or equal to the maximum input value and the leaf is not supported on that processor then 0 is returned in all the registers. For example, using the Intel Core i7 processor, the following is true:</p>
<pre>CPUID.EAX = 07H (* Returns EAX=EBX=ECX=EDX=0. *)</pre>
<p>When CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence on input ECX value in the basic leaf is honored.</p>
<p>CPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed.</p>
<table>
  <caption>Information Returned by CPUID Instruction</caption>
  <tr>
    <th>Initial EAX Value</th>
    <th>Information Provided about the Processor</th>
  </tr>
  <tr>
    <td>0H</td>
    <td>
      <p>Basic CPUID Information:</p>
      <table>
        <tr>
          <td>EAX</td>
          <td>Maximum Input Value for Basic CPUID Information (see Table 3-13)</td>
        </tr>
        <tr>
          <td>EBX</td>
          <td>"Genu"</td>
        </tr>
        <tr>
          <td>ECX</td>
          <td>"ntel"</td>
        </tr>
        <tr>
          <td>EDX</td>
          <td>"ineI"</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>01H</td>
    <td>
      <table>
        <tr>
          <td>EAX</td>
          <td>Version Information: Type, Family, Model, and Stepping ID (see Figure 3-5)</td>
        </tr>
        <tr>
          <td>EBX</td>
          <td>Bits 7-0: Brand Index</td>
        <tr><td />
          <td>Bits 15-8: CLFLUSH line size (Value * 8 = cache line size in bytes)</td>
        </tr><tr><td />
          <td>Bits 23-16: Maximum number of addressable IDs for logical processors in this physical package*.</td>
        </tr><tr><td />
          <td>Bits 31-24: Initial APIC ID</td>
        </tr></tr>
        <tr>
          <td>ECX</td>
          <td>Feature Information (see Figure 3-6 and Table 3-15)</td>
        </tr>
        <tr>
          <td>EDX</td>
          <td>Feature Information (see Figure 3-7 and Table 3-16)</td>
        </tr>
      </table>
      <ul>
        <li><b>Notes:</b></li>
        <li>* The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number of unique initial APIC IDs reserved for addressing different logical processors in a physical package.</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>02H</td>
    <td>
      <table>
        <tr>
          <td>EAX</td>
          <td>Cache and TLB Information (see Table 3-17)</td>
        </tr>
        <tr>
          <td>EBX</td>
          <td>Cache and TLB Information</td>
        </tr>
        <tr>
          <td>ECX</td>
          <td>Cache and TLB Information</td>
        </tr>
        <tr>
          <td>EDX</td>
          <td>Cache and TLB Information</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>03H</td>
    <td>
      <table>
        <tr>
          <td>EAX</td>
          <td>Reserved.</td>
        </tr>
        <tr>
          <td>EBX</td>
          <td>Reserved.</td>
        </tr>
        <tr>
          <td>ECX</td>
          <td>Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</td>
        </tr>
        <tr>
          <td>EDX</td>
          <td>Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</td>
        </tr>
      </table>
      <ul>
        <li><b>Notes:</b></li>
        <li>Processor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature.</li>
        <li>See AP-485, <i>Intel Processor Identification</i> and the CPUID Instruction (Order Number 241618) for more information on PSN.</li>
        <li>CPUID leaves &gt; 3 &lt; 80000000 are visible only when IA32_MISC_ENABLES.BOOT_NT4[bit 22] = 0 (default).</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td />
    <td><i>Deterministic Cache Parameters Leaf</i></td>
  </tr>
  <tr>
    <td>04H</td>
    <td>
      <table>
        <tr>
          <td>EAX</td>
          <td>
            <ul>
              <li>Bits 4-0: Cache Type Field</li>
              <ul>
                <li>0 = Null - No more caches</li>
                <li>1 = Data Cache</li>
                <li>2 = Instruction Cache</li>
                <li>3 = Unified Cache</li>
                <li>4-31 = Reserved Bits</li>
              </ul>
              <li>7-5: Cache Level (starts at 1)</li>
              <li>Bits 8: Self Initializing cache level (does not need SW initialization)</li>
              <li>Bits 9: Fully Associative cache</li>
              <li>Bits 13-10: Reserved</li>
              <li>Bits 25-14: Maximum number of addressable IDs for logical processors sharing this cache*, **</li>
              <li>Bits 31-26: Maximum number of addressable IDs for processor cores in the physical package*, ***, ****</li>
            </ul>
      </table>
    </td>
  </tr>
  <tr>
    <td />
    <td>
      <table>
        <tr>
          <td>EBX</td>
          <td>Bits 11-00: L = System Coherency Line Size*</td>
        </tr>
        <tr>
          <td />
          <td>Bits 21-12: P = Physical Line partitions*</td>
        </tr>
        <tr>
          <td />
          <td>Bits 31-22: W = Ways of associativity*</td>
        </tr>
        <tr>
          <td>ECX</td>
          <td>Bits 31-00: S = Number of Sets* Information Provided about the Processor</td>
        </tr>
      </table>
  </tr>
  <tr>
    <td />
    <td>
      <table>
        <tr>
          <td>EDX</td>
          <td>
            <ul>
              <li>Bit 0: Write-Back Invalidate/Invalidate</li>
              <li>
                <ul>
                  <li>0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache.</li>
                  <li>1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.</li>
                </ul>
              </li>
              <li>Bit 1: Cache Inclusiveness</li>
              <li>
                <ul>
                  <li>0 = Cache is not inclusive of lower cache levels.</li>
                  <li>1 = Cache is inclusive of lower cache levels.</li>
                </ul>
              </li>
              <li>Bit 2: Complex Cache Indexing</li>
              <li>
                <ul>
                  <li>0 = Direct mapped cache.</li>
                  <li>1 = A complex function is used to index the cache, potentially using all address bits.</li>
                </ul>
              </li>
              <li>Bits 31-03: Reserved = 0</li>
            </ul>
            <ul>
              <li><b>Notes:</b></li>
              <li>Leaf 04H output depends on the initial value in ECX. See also: INPUT EAX = 4: Returns Deterministic Cache Parameters for each level on page 3-221.</li>
              <li>* Add one to the return value to get the result.</li>
              <li>** The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique initial APIC IDs reserved for addressing different logical processors sharing this cache</li>
              <li>*** The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique Core_IDs reserved for addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.</li>
              <li>****The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>MONITOR/MWAIT Leaf</i></td>
        </tr>
        <tr>
          <td>05H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity)</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-16: Reserved = 0</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity)</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-16: Reserved = 0</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td>
            <table>
              <tr>
                <td>ECX</td>
                <td>Bit 00: Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported</td>
              </tr>
              <tr>
                <td />
                <td>Bit 01: Supports treating interrupts as break-event for MWAIT, even when interrupts disabled</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31 - 02: Reserved Information Provided about the Processor</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td>
            <table>
              <tr>
                <td>EDX</td>
                <td>Bits 03 - 00: Number of C0* sub C-states supported using MWAIT</td>
              </tr>
              <tr>
                <td />
                <td>Bits 07 - 04: Number of C1* sub C-states supported using MWAIT</td>
              </tr>
              <tr>
                <td />
                <td>Bits 11 - 08: Number of C2* sub C-states supported using MWAIT</td>
              </tr>
              <tr>
                <td />
                <td>Bits 15 - 12: Number of C3* sub C-states supported using MWAIT</td>
              </tr>
              <tr>
                <td />
                <td>Bits 19 - 16: Number of C4* sub C-states supported using MWAIT</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31 - 20: Reserved = 0</td>
              </tr>
            </table>
            <ul>
              <li><b>Notes:</b></li>
              <li>* The definition of C0 through C4 states for MWAIT extension are processor-specific C-states, not ACPI C-states.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>Thermal and Power Management Leaf</i></td>
        </tr>
        <tr>
          <td>06H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Bit 00: Digital temperature sensor is supported if set</td>
              </tr>
              <tr>
                <td />
                <td>Bit 01: Intel Turbo Boost Technology Available (see description of IA32_MISC_ENABLES[38]).</td>
              </tr>
              <tr>
                <td />
                <td>Bit 02: ARAT. APIC-Timer-always-running feature is supported if set.</td>
              </tr>
              <tr>
                <td />
                <td>Bit 03: Reserved Bit</td>
              </tr>
              <tr>
                <td />
                <td>04: PLN. Power limit notification controls are supported if set.</td>
              </tr>
              <tr>
                <td />
                <td>Bit 05: ECMD. Clock modulation duty cycle extension is supported if set.</td>
              </tr>
              <tr>
                <td />
                <td>Bit 06: PTM. Package thermal management is supported if set.</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31 - 07: Reserved</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Bits 03 - 00: Number of Interrupt Thresholds in Digital Thermal Sensor</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31 - 04: Reserved</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td>
            <table>
              <tr>
                <td>ECX</td>
                <td>Bit 00: Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a measure of delivered processor performance (since last reset of the counters), as a percentage of expected processor performance at frequency specified in CPUID Brand String</td>
              </tr>
              <tr>
                <td />
                <td>Bits 02 - 01: Reserved = 0</td>
              </tr>
              <tr>
                <td />
                <td>Bit 03: The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H)</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31 - 04: Reserved = 0</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Reserved = 0</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>Direct Cache Access Information Leaf</i></td>
        </tr>
        <tr>
          <td>09H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H)</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Reserved</td>
              </tr>
            </table>
        </tr>
        <tr>
          <td />
          <td><i>Architectural Performance Monitoring Leaf</i></td>
        </tr>
        <tr>
          <td>0AH</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Bits 07 - 00: Version ID of architectural performance monitoring</td>
              </tr>
              <tr>
                <td />
                <td>Bits 15- 08: Number of general-purpose performance monitoring counter per logical processor</td>
              </tr>
              <tr>
                <td />
                <td>Bits 23 - 16: Bit width of general-purpose, performance monitoring counter</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31 - 24: Length of EBX bit vector to enumerate architectural performance monitoring events</td>
              </tr>
            </table>
        </tr>
        <tr>
          <td />
          <td>
            <table>
              <tr>
                <td>EBX</td>
                <td>Bit 0: Core cycle event not available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bit 1: Instruction retired event not available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bit 2: Reference cycles event not available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bit 3: Last-level cache reference event not available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bit 4: Last-level cache misses event not available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bit 5: Branch instruction retired event not available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bit 6: Branch mispredict retired event not available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31- 07: Reserved = 0</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Reserved = 0</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td>
            <table>
              <tr>
                <td>EDX</td>
                <td>Bits 04 - 00: Number of fixed-function performance counters (if Version ID &gt; 1)</td>
              </tr>
              <tr>
                <td />
                <td>Bits 12- 05: Bit width of fixed-function performance counters (if Version ID &gt; 1)</td>
              </tr>
              <tr>
                <td />
                <td>Reserved = 0</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>Extended Topology Enumeration Leaf</i></td>
        </tr>
        <tr>
          <td>0BH</td>
          <td>
            <ul>
              <li><b>Notes:</b></li>
              <li>Most of Leaf 0BH output depends on the initial value in ECX. EDX output do not vary with initial value in ECX. ECX[7:0] output always reflect initial value in ECX. All other output value for an invalid initial value in ECX are 0. Leaf 0BH exists if EBX[15:0] is not zero.</li>
            </ul>
            <table>
              <tr>
                <td>EAX</td>
                <td>Bits 4-0: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type*. All logical processors with the same next level ID share current level.</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-5: Reserved.</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Bits 15 - 00: Number of logical processors at this level type. The number reflects configuration as shipped by Intel**.</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31- 16: Reserved.</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Bits 07 - 00: Level number. Same value in ECX input</td>
              </tr>
              <tr>
                <td />
                <td>Bits 15 - 08: Level type***.
              </tr>
              <tr>
                <td />
                <td>Bits 31 - 16:: Reserved.</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Bits 31- 0: x2APIC ID the current logical processor. Information Provided about the Processor</td>
              </tr>
            </table>
            <ul>
              <li><b>Notes:</b></li>
              <li>* Software should use this field (EAX[4:0]) to enumerate processor topology of the system.</li>
              <li>** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware configurations.</li>
              <li>*** The value of the "level type" field is not related to level numbers in any way, higher "level type" values do not mean higher levels. Level type field has the following encoding:</li>
              <li>
                <ul>
                  <li>0 : invalid</li>
                  <li>1 : SMT</li>
                  <li>2 : Core</li>
                  <li>3-255 : Reserved</li>
                </ul>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>Processor Extended State Enumeration Main Leaf</i> (EAX = 0DH, ECX = 0)</td>
        </tr>
        <tr>
          <td>0DH</td>
          <td>
            <ul>
              <li><b>Notes:</b></li>
              <li>Leaf 0DH main leaf (ECX = 0).</li>
            </ul>
            <table>
              <tr>
                <td>EAX</td>
                <td>Bits 31-0: Reports the valid bit fields of the lower 32 bits of the XFEATURE_ENABLED_MASK register (XCR0). If a bit is 0, the corresponding bit field in XCR0 is reserved.</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Bits 31-0: Maximum size (bytes) required by enabled features in XFEATURE_ENABLED_MASK (XCR0). May be different than ECX when features at the end of the save area are not enabled.</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Bit 31-0: Maximum size (bytes) of the XSAVE/XRSTOR save area required by all supported features in the processor, i.e all the valid bit fields in XFEATURE_ENABLED_MASK. This includes the size needed for the XSAVE.HEADER.</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Bit 31-0: Reports the valid bit fields of the upper 32 bits of the XFEATURE_ENABLED_MASK register (XCR0). If a bit is 0, the corresponding bit field in XCR0 is reserved. Information Provided about the Processor</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>Processor Extended State Enumeration Sub-leaf</i> (EAX = 0DH, ECX = 1)</td>
        </tr>
        <tr>
          <td />
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Reserved</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>Processor Extended State Enumeration Sub-leaves</i> (EAX = 0DH, ECX = n, n &gt; 1)</td>
        </tr>
        <tr>
          <td>0DH</td>
          <td>
            <ul>
              <li><b>Notes:</b></li>
              <li>Leaf 0DH output depends on the initial value in ECX.</li>
              <li>If ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0.</li>
            </ul>
            <table>
              <tr>
                <td>EAX</td>
                <td>Bits 31-0: The size in bytes of the save area for an extended state feature associated with a valid sub-leaf index, n. Each valid sub-leaf index maps to a valid bit in the XFEATURE_ENABLED_MASK register (XCR0) starting at bit position 2. This field reports 0 if the sub-leaf index, n, is invalid*.</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Bits 31-0: The offset in bytes of the save area from the beginning of the XSAVE/XRSTOR area. This field reports 0 if the sub-leaf index, n, is invalid*.</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>This field reports 0 if the sub-leaf index, n, is invalid*; otherwise it is reserved.</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td />
          <td><i>Unimplemented CPUID Leaf Functions</i></td>
        </tr>
        <tr>
          <td>40000000H - 4FFFFFFFH</td>
          <td>Invalid. No existing or future CPU will return processor identification or feature information if the initial EAX value is in the range 40000000H to 4FFFFFFFH.</td>
        </tr>
        <tr>
          <td />
          <td><i>Extended Function CPUID Information</i></td>
        </tr>
        <tr>
          <td>80000000H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Maximum Input Value for Extended Function CPUID Information (see Table 3-13).</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Reserved</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>80000001H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Extended Processor Signature and Feature Bits.</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Bit 0: LAHF/SAHF available in 64-bit mode</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-1 Reserved</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Bits 10-0: Reserved</td>
              </tr>
              <tr>
                <td />
                <td>Bit 11: SYSCALL/SYSRET available (when in 64-bit mode)</td>
              </tr>
              <tr>
                <td />
                <td>Bits 19-12: Reserved = 0</td>
              </tr>
              <tr>
                <td />
                <td>Bit 20: Execute Disable Bit available</td>
              </tr>
              <tr>
                <td />
                <td>Bits 25-21: Reserved = 0</td>
              </tr>
              <tr>
                <td />
                <td>Bit 26: 1-GByte pages are available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bit 27: RDTSCP and IA32_TSC_AUX are available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bits 28: Reserved = 0</td>
              </tr>
              <tr>
                <td />
                <td>Bit 29: Intel® 64 Architecture available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-30: Reserved = 0</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>80000002H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Processor Brand String</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Processor Brand String Continued</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>80000003H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Processor Brand String Continued</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>80000004H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Processor Brand String Continued</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Processor Brand String Continued</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>80000005H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Reserved = 0</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>80000006H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Bits 7-0: Cache Line size in bytes</td>
              </tr>
              <tr>
                <td />
                <td>Bits 15-12: L2 Associativity field *</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-16: Cache size in 1K units</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Reserved = 0 Information Provided about the Processor</td>
              </tr>
            </table>
            <ul>
              <li><b>Notes:</b></li>
              <li>* L2 associativity field encodings:</li>
              <li>
                <ul>
                  <li>00H - Disabled</li>
                  <li>01H - Direct mapped</li>
                  <li>02H - 2-way</li>
                  <li>04H - 4-way</li>
                  <li>06H - 8-way</li>
                  <li>08H - 16-way</li>
                  <li>0FH - Fully associative</li>
                </ul>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>80000007H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>EDX</td>
                <td>Bits 7-0: Reserved = 0>/td>
              </tr>
              <tr>
                <td />
                <td>Bit 8: Invariant TSC available if 1</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-9: Reserved = 0</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>80000008H</td>
          <td>
            <table>
              <tr>
                <td>EAX</td>
                <td>Linear/Physical Address size</td>
              </tr>
              <tr>
                <td />
                <td>Bits 7-0: #Physical Address Bits*</td>
              </tr>
              <tr>
                <td />
                <td>Bits 15-8: #Linear Address Bits</td>
              </tr>
              <tr>
                <td />
                <td>Bits 31-16: Reserved = 0</td>
              </tr>
              <tr>
                <td>EBX</td>
                <td>Reserved = 0</td>
              </tr>
              <tr>
                <td>ECX</td>
                <td>Reserved = 0</td>
              </tr>
            </table>
            <ul>
              <li><b>Notes:</b></li>
              <li>* If CPUID.80000008H:EAX[7:0] is supported, the maximum physical address number supported should come from this field.</li>
            </ul>
          </td>
        </tr>
      </table>
      <h3>INPUT EAX = 0: Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification String</h3>
      <p>When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic processor information. The value is returned in the EAX register (see the following table) and is processor specific.</p>
      <p>A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel" and is expressed:</p>
      <ul>
        <li>EBX = 756e6547h (* "Genu", with G in the low eight bits of BL *)</li>
        <li>EDX = 49656e69h (* "ineI", with i in the low eight bits of DL *)</li>
        <li>ECX = 6c65746eh (* "ntel", with n in the low eight bits of CL *)</li>
      </ul>
      <h3>INPUT EAX = 80000000H: Returns CPUID's Highest Value for Extended Processor Information</h3>
      <p>When CPUID executes with EAX set to 80000000H, the processor returns the highest value the processor recognizes for returning extended processor information. The value is returned in the EAX register (see the following table) and is processor specific.</p>
      <table>
        <caption>Highest CPUID Source Operand for Intel 64 and IA-32 Processors</caption>
        <tr>
          <th>Intel 64 or IA-32 Processors</th>
          <th colspan="2">Highest Value in EAX</th>
        </tr>
        <tr>
          <th />
          <th>Basic Information</th>
          <th>Extended Function Information</th>
        </tr>
        <tr>
          <td>Earlier Intel486 Processors</td>
          <td>CPUID Not Implemented</td>
          <td>CPUID Not Implemented</td>
        </tr>
        <tr>
          <td>Later Intel486 Processors and Pentium Processors</td>
          <td>01H</td>
          <td>Not Implemented</td>
        </tr>
        <tr>
          <td>Pentium Pro and Pentium II Processors, Intel® Celeron® Processors</td>
          <td>02H</td>
          <td>Not Implemented</td>
        </tr>
        <tr>
          <td>Pentium III Processors</td>
          <td>03H</td>
          <td>Not Implemented</td>
        </tr>
        <tr>
          <td>Pentium 4 Processors</td>
          <td>02H</td>
          <td>80000004H</td>
        </tr>
        <tr>
          <td>Intel Xeon Processors</td>
          <td>02H</td>
          <td>80000004H</td>
        </tr>
        <tr>
          <td>Pentium M Processor</td>
          <td>02H</td>
          <td>80000004H</td>
        </tr>
        <tr>
          <td>Pentium 4 Processor supporting Hyper-Threading Technology</td>
          <td>05H</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Pentium D Processor (8xx)</td>
          <td>05H</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Pentium D Processor (9xx)</td>
          <td>06H</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Intel Core Duo Processor</td>
          <td>0AH</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Intel Core 2 Duo Processor</td>
          <td>0AH</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Intel Xeon Processor 3000, 5100, 5200, 5300, 5400 Series</td>
          <td>0AH</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Intel Core 2 Duo Processor 8000 Series</td>
          <td>0DH</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Intel Xeon Processor 5200, 5400 Series</td>
          <td>0AH</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Intel Atom Processor</td>
          <td>0AH</td>
          <td>80000008H</td>
        </tr>
        <tr>
          <td>Intel Core i7 Processor</td>
          <td>0BH</td>
          <td>80000008H</td>
        </tr>
      </table>
      <h3>IA32_BIOS_SIGN_ID Returns Microcode Update Signature</h3>
      <p>For processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update signature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 9 in theIntel® 64 and IA-32Architectures Software Developer's Manual, Volume 3A.</p>
      <h3>INPUT EAX = 1: Returns Model, Family, Stepping Information</h3>
      <p>When CPUID executes with EAX set to 1, version information is returned in EAX (see Figure 3-5). For example: model, family, and processor type for the Intel Xeonprocessor 5100 series is as follows:</p>
      <ul>
        <li>Model — 1111B </li>
        <li>Family — 0101B </li>
        <li>Processor Type — 00B </li>
      </ul>
      <p>See the following for available processor type values. Stepping IDs are provided as needed.</p>
      <table>
        <caption>Processor Type Field</caption>
        <tr>
          <th>Type</th>
          <th>Encoding</th>
        </tr>
        <tr>
          <td>Original OEM Processor</td>
          <td>00B</td>
        </tr>
        <tr>
          <td>Intel OverDrive® Processor</td>
          <td>01B</td>
        </tr>
        <tr>
          <td>Dual processor (not applicable to Intel486 processors)</td>
          <td>10B</td>
        </tr>
        <tr>
          <td>Intel reserved</td>
          <td>11B</td>
        </tr>
      </table>
      <p>The Extended Family ID needs to be examined only when the Family ID is 0FH. Integrate the fields into a display using the following rule:</p>
      <pre>IF Family_ID != 0FH
        THEN DisplayFamily = Family_ID;
        ELSE DisplayFamily = Extended_Family_ID + Family_ID;
        (* Right justify and zero-extend 4-bit field. *)
        FI;
        (* Show DisplayFamily as HEX field. *)</pre>
      <p>The Extended Model ID needs to be examined only when the Family ID is 06H or 0FH. Integrate the field into a display using the following rule:</p>
      <pre>IF (Family_ID = 06H or Family_ID = 0FH)
        THEN DisplayModel = (Extended_Model_ID &lt;&lt; 4) + Model_ID;
        (* Right justify and zero-extend 4-bit field; display Model_ID as HEX field.*)
        ELSE DisplayModel = Model_ID;
        FI;
        (* Show DisplayModel as HEX field. *)</pre>
      <h3>INPUT EAX = 1: Returns Additional Information in EBX</h3>
      <p>When CPUID executes with EAX set to 1, additional information is returned to the EBX register:</p>
      <ul>
        <li>Brand index (low byte of EBX) — this number provides an entry into a brand string table that contains brand strings for IA-32 processors. More information about this field is provided later in this section.</li>
        <li>CLFLUSH instruction cache line size (second byte of EBX) — this number indicates the size of the cache line flushed with CLFLUSH instruction in 8-byte increments. This field was introduced in the Pentium 4 processor.</li>
        <li>Local APIC ID (high byte of EBX) — this number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field was introduced in the Pentium 4 processor.</li>
      </ul>
      <p>INPUT EAX = 1: Returns Feature Information in ECX and EDX</p>
      <p>When CPUID executes with EAX set to 1, feature information is returned in ECX and EDX.</p>
      <ul>
        <li>Figure 3-6 and Table 3-15 show encodings for ECX.</li>
        <li>Figure 3-7 and Table 3-16 show encodings for EDX.</li>
      </ul>
      <p>For all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.</p>
      <p>NOTE</p>
      <p>Software must confirm that a processor feature is present using feature flags returned by CPUID prior to using the feature. Software should not depend on future offerings retaining all features.</p>
      <p>Figure 3-6. Feature Information Returned in the ECX Register
        Table 3-15. Feature Information Returned in the ECX Register
      </p>
      <table>
        <tr>
          <th>Bit #</th>
          <th>Mnemonic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>0</td>
          <td>SSE3</td>
          <td>Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.</td>
        </tr>
        <tr>
          <td>1</td>
          <td>PCLMULQDQ</td>
          <td>PCLMULQDQ. A value of 1 indicates the processor supports the PCLMULQDQ instruction</td>
        </tr>
        <tr>
          <td>2</td>
          <td>DTES64</td>
          <td>64-bit DS Area. A value of 1 indicates the processor supports DS area using 64-bit layout</td>
        </tr>
        <tr>
          <td>3</td>
          <td>MONITOR</td>
          <td>MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.</td>
        </tr>
      </table>
      <p>Table 3-15. Feature Information Returned in the ECX Register (Contd.)</p>
      <table>
        <tr>
          <th>Bit #</th>
          <th>Mnemonic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>4</td>
          <td>DS-CPL</td>
          <td>CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.</td>
        </tr>
        <tr>
          <td>5</td>
          <td>VMX</td>
          <td>Virtual Machine Extensions. A value of 1 indicates that the processor supports this technology</td>
        </tr>
        <tr>
          <td>6</td>
          <td>SMX</td>
          <td>Safer Mode Extensions. A value of 1 indicates that the processor supports this technology. See Chapter 6, "Safer Mode Extensions Reference".</td>
        </tr>
        <tr>
          <td>7</td>
          <td>EST</td>
          <td>Enhanced Intel SpeedStep® technology. A value of 1 indicates that the processor supports this technology.</td>
        </tr>
        <tr>
          <td>8</td>
          <td>TM2</td>
          <td>Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.</td>
        </tr>
        <tr>
          <td>9</td>
          <td>SSSE3</td>
          <td>A value of 1 indicates the presence of the Supplemental Streaming SIMD Extensions 3 (SSSE3). A value of 0 indicates the instruction extensions are not present in the processor</td>
        </tr>
        <tr>
          <td>10</td>
          <td>CNXT-ID</td>
          <td>L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.</td>
        </tr>
        <tr>
          <td>11</td>
          <td>Reserved</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>12</td>
          <td>FMA</td>
          <td>A value of 1 indicates the processor supports FMA extensions using YMM state.</td>
        </tr>
        <tr>
          <td>13</td>
          <td>CMPXCHG16B</td>
          <td>CMPXCHG16B Available. A value of 1 indicates that the feature is available. See the "CMPXCHG8B/CMPXCHG16B—Compare and Exchange Bytes" section in this chapter for a description.</td>
        </tr>
        <tr>
          <td>14</td>
          <td>xTPR Update Control</td>
          <td>xTPR Update Control. A value of 1 indicates that the processor supports changing IA32_MISC_ENABLES[bit 23].</td>
        </tr>
        <tr>
          <td>15</td>
          <td>PDCM</td>
          <td>Perfmon and Debug Capability: A value of 1 indicates the processor supports the performance and debug feature indication MSR IA32_PERF_CAPABILITIES.</td>
        </tr>
        <tr>
          <td>16</td>
          <td>Reserved</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>17</td>
          <td>PCID</td>
          <td>Process-context identifiers. A value of 1 indicates that the processor supports PCIDs and that software may set CR4.PCIDE to 1.</td>
        </tr>
        <tr>
          <td>18</td>
          <td>DCA</td>
          <td>A value of 1 indicates the processor supports the ability to prefetch data from a memory mapped device.</td>
        </tr>
        <tr>
          <td>19</td>
          <td>SSE4.1</td>
          <td>A value of 1 indicates that the processor supports SSE4.1.</td>
        </tr>
        <tr>
          <td>20</td>
          <td>SSE4.2</td>
          <td>A value of 1 indicates that the processor supports SSE4.2.</td>
        </tr>
      </table>
      <p>Table 3-15. Feature Information Returned in the ECX Register (Contd.)</p>
      <table>
        <tr>
          <th>Bit #</th>
          <th>Mnemonic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>21</td>
          <td>x2APIC</td>
          <td>A value of 1 indicates that the processor supports x2APIC feature.</td>
        </tr>
        <tr>
          <td>22</td>
          <td>MOVBE</td>
          <td>A value of 1 indicates that the processor supports MOVBE instruction.</td>
        </tr>
        <tr>
          <td>23</td>
          <td>POPCNT</td>
          <td>A value of 1 indicates that the processor supports the POPCNT instruction.</td>
        </tr>
        <tr>
          <td>24</td>
          <td>TSC-Deadline</td>
          <td>A value of 1 indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline value.</td>
        </tr>
        <tr>
          <td>25</td>
          <td>AESNI</td>
          <td>A value of 1 indicates that the processor supports the AESNI instruction extensions.</td>
        </tr>
        <tr>
          <td>26</td>
          <td>XSAVE</td>
          <td>A value of 1 indicates that the processor supports the XSAVE/XRSTOR processor extended states feature, the XSETBV/XGETBV instructions, and the XFEATURE_ENABLED_MASK register (XCR0).</td>
        </tr>
        <tr>
          <td>27</td>
          <td>OSXSAVE</td>
          <td>A value of 1 indicates that the OS has enabled XSETBV/XGETBV instructions to access the XFEATURE_ENABLED_MASK register (XCR0), and support for processor extended state management using XSAVE/XRSTOR.</td>
        </tr>
        <tr>
          <td>28</td>
          <td>AVX</td>
          <td>A value of 1 indicates the processor supports the AVX instruction extensions.</td>
        </tr>
        <tr>
          <td>30 - 29</td>
          <td>Reserved</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>31</td>
          <td>Not Used</td>
          <td>Always returns 0</td>
        </tr>
      </table>
      <p>Figure 3-7. Feature Information Returned in the EDX Register</p>
      <p>Table 3-16. More on Feature Information Returned in the EDX Register</p>
      <table>
        <tr>
          <th>Bit #</th>
          <th>Mnemonic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>0</td>
          <td>FPU</td>
          <td>Floating Point Unit On-Chip. The processor contains an x87 FPU.</td>
        </tr>
        <tr>
          <td>1</td>
          <td>VME</td>
          <td>Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.</td>
        </tr>
        <tr>
          <td>2</td>
          <td>DE</td>
          <td>Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.</td>
        </tr>
        <tr>
          <td>3</td>
          <td>PSE</td>
          <td>Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.</td>
        </tr>
        <tr>
          <td>4</td>
          <td>TSC</td>
          <td>Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.</td>
        </tr>
        <tr>
          <td>5</td>
          <td>MSR</td>
          <td>Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.</td>
        </tr>
        <tr>
          <td>6</td>
          <td>PAE</td>
          <td>Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1.</td>
        </tr>
        <tr>
          <td>7</td>
          <td>MCE</td>
          <td>Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.</td>
        </tr>
        <tr>
          <td>8</td>
          <td>CX8</td>
          <td>CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).</td>
        </tr>
        <tr>
          <td>9</td>
          <td>APIC</td>
          <td>APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).</td>
        </tr>
        <tr>
          <td>10</td>
          <td>Reserved</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>11</td>
          <td>SEP</td>
          <td>SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported.</td>
        </tr>
        <tr>
          <td>12</td>
          <td>MTRR</td>
          <td>Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.</td>
        </tr>
      </table>
      <p>Table 3-16. More on Feature Information Returned in the EDX Register (Contd.) Table 3-16. More on Feature Information Returned in the EDX Register (Contd.)</p>
      <table>
        <tr>
          <th>Bit #</th>
          <th>Mnemonic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>13</td>
          <td>PGE</td>
          <td>Page Global Bit. The global bit is supported in paging-structure entries that map a page, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.</td>
        </tr>
        <tr>
          <td>14</td>
          <td>MCA</td>
          <td>Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for error reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.</td>
        </tr>
        <tr>
          <td>15</td>
          <td>CMOV</td>
          <td>Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported</td>
        </tr>
        <tr>
          <td>16</td>
          <td>PAT</td>
          <td>Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory accessed through a linear address on a 4KB granularity.</td>
        </tr>
        <tr>
          <td>17</td>
          <td>PSE-36</td>
          <td>36-Bit Page Size Extension. 4-MByte pages addressing physical memory beyond 4 GBytes are supported with 32-bit paging. This feature indicates that upper bits of the physical address of a 4-MByte page are encoded in bits 20:13 of the page-directory entry. Such physical addresses are limited by MAXPHYADDR and may be up to 40 bits in size.</td>
        </tr>
        <tr>
          <td>18</td>
          <td>PSN</td>
          <td>Processor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.</td>
        </tr>
        <tr>
          <td>19</td>
          <td>CLFSH</td>
          <td>CLFLUSH Instruction. CLFLUSH Instruction is supported.</td>
        </tr>
        <tr>
          <td>20</td>
          <td>Reserved</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>21</td>
          <td>DS</td>
          <td>Debug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see Chapter 20, "Introduction to Virtual-Machine Extensions," in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3B).</td>
        </tr>
        <tr>
          <td>22</td>
          <td>ACPI</td>
          <td>Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.</td>
        </tr>
        <tr>
          <td>23</td>
          <td>MMX</td>
          <td>Intel MMX Technology. The processor supports the Intel MMX technology.</td>
        </tr>
        <tr>
          <td>24</td>
          <td>FXSR</td>
          <td>FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.</td>
        </tr>
        <tr>
          <th>Bit #</th>
          <th>Mnemonic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>25</td>
          <td>SSE</td>
          <td>SSE. The processor supports the SSE extensions.</td>
        </tr>
        <tr>
          <td>26</td>
          <td>SSE2</td>
          <td>SSE2. The processor supports the SSE2 extensions.</td>
        </tr>
        <tr>
          <td>27</td>
          <td>SS</td>
          <td>Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.</td>
        </tr>
        <tr>
          <td>28</td>
          <td>HTT</td>
          <td>Multi-Threading. The physical processor package is capable of supporting more than one logical processor.</td>
        </tr>
        <tr>
          <td>29</td>
          <td>TM</td>
          <td>Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).</td>
        </tr>
        <tr>
          <td>30</td>
          <td>Reserved</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>31</td>
          <td>PBE</td>
          <td>Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.</td>
        </tr>
      </table>
      <p>INPUT EAX = 2: TLB/Cache/Prefetch Information Returned in EAX, EBX, ECX, EDX</p>
      <p>When CPUID executes with EAX set to 2, the processor returns information about the processor's internal TLBs, cache and prefetch hardware in the EAX, EBX, ECX, and EDX registers. The information is reported in encoded form and fall into the following categories:</p>
      <ul>
        <li>The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction must be executed with an input value of 2 to get a complete description of the processor's TLB/Cache/Prefetch hardware. The Intel Xeon processor 7400 series will return a 1.</li>
        <li>The most significant bit (bit 31) of each register indicates whether the register contains valid information (set to 0) or is reserved (set to 1).</li>
        <li>If a register contains valid information, the information is contained in 1 byte descriptors. There are four types of encoding values for the byte descriptor, the encoding type is noted in the second column of Table 3-17. Table 3-17 lists theencoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not defined; that is, specific bytes are not designated to contain descriptors for specific cache, prefetch, or TLB types. The descriptors may appear in any order. Note also a processor may report a general descriptor type (FFH) and not report any byte descriptor of "cache type" via CPUID leaf 2.</li>
      </ul>
      <p>Table 3-17. Encoding of CPUID Leaf 2 Descriptors</p>
      <table>
        <tr>
          <th>Value</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>00H</td>
          <td>General</td>
          <td>Null descriptor, this byte contains no information</td>
        </tr>
        <tr>
          <td>01H</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 KByte pages, 4-way set associative, 32 entries</td>
        </tr>
        <tr>
          <td>02H</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 MByte pages, fully associative, 2 entries</td>
        </tr>
        <tr>
          <td>03H</td>
          <td>TLB</td>
          <td>Data TLB: 4 KByte pages, 4-way set associative, 64 entries</td>
        </tr>
        <tr>
          <td>04H</td>
          <td>TLB</td>
          <td>Data TLB: 4 MByte pages, 4-way set associative, 8 entries</td>
        </tr>
        <tr>
          <td>05H</td>
          <td>TLB</td>
          <td>Data TLB1: 4 MByte pages, 4-way set associative, 32 entries</td>
        </tr>
        <tr>
          <td>06H</td>
          <td>Cache</td>
          <td>1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>08H</td>
          <td>Cache</td>
          <td>1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>09H</td>
          <td>Cache</td>
          <td>1st-level instruction cache: 32KBytes, 4-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>0AH</td>
          <td>Cache</td>
          <td>1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>0BH</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries</td>
        </tr>
        <tr>
          <td>0CH</td>
          <td>Cache</td>
          <td>1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>0DH</td>
          <td>Cache</td>
          <td>1st-level data cache: 16 KBytes, 4-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>0EH</td>
          <td>Cache</td>
          <td>1st-level data cache: 24 KBytes, 6-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>21H</td>
          <td>Cache</td>
          <td>2nd-level cache: 256 KBytes, 8-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>22H</td>
          <td>Cache</td>
          <td>3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
        <tr>
          <td>23H</td>
          <td>Cache</td>
          <td>3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
        <tr>
          <td>25H</td>
          <td>Cache</td>
          <td>3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
        <tr>
          <td>29H</td>
          <td>Cache</td>
          <td>3rd-level cache: 4 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
        <tr>
          <td>2CH</td>
          <td>Cache</td>
          <td>1st-level data cache: 32 KBytes, 8-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>30H</td>
          <td>Cache</td>
          <td>1st-level instruction cache: 32 KBytes, 8-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>40H</td>
          <td>Cache</td>
          <td>No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rdlevel cache</td>
        </tr>
        <tr>
          <td>41H</td>
          <td>Cache</td>
          <td>2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>42H</td>
          <td>Cache</td>
          <td>2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>43H</td>
          <td>Cache</td>
          <td>2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>44H</td>
          <td>Cache</td>
          <td>2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>45H</td>
          <td>Cache</td>
          <td>2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size</td>
        </tr>
      </table>
      <p>Table 3-17. Encoding of CPUID Leaf 2 Descriptors (Contd.)</p>
      <table>
        <tr>
          <th>Value</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>46H</td>
          <td>Cache</td>
          <td>3rd-level cache: 4 MByte, 4-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>47H</td>
          <td>Cache</td>
          <td>3rd-level cache: 8 MByte, 8-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>48H</td>
          <td>Cache</td>
          <td>2nd-level cache: 3MByte, 12-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>49H</td>
          <td>Cache</td>
          <td>3rd-level cache: 4MB, 16-way set associative, 64-byte line size (Intel Xeon processor MP, Family 0FH, Model 06H); 2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>4AH</td>
          <td>Cache</td>
          <td>3rd-level cache: 6MByte, 12-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>4BH</td>
          <td>Cache</td>
          <td>3rd-level cache: 8MByte, 16-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>4CH</td>
          <td>Cache</td>
          <td>3rd-level cache: 12MByte, 12-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>4DH</td>
          <td>Cache</td>
          <td>3rd-level cache: 16MByte, 16-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>4EH</td>
          <td>Cache</td>
          <td>2nd-level cache: 6MByte, 24-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>4FH</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 KByte pages, 32 entries</td>
        </tr>
        <tr>
          <td>50H</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries</td>
        </tr>
        <tr>
          <td>51H</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries</td>
        </tr>
        <tr>
          <td>52H</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries</td>
        </tr>
        <tr>
          <td>55H</td>
          <td>TLB</td>
          <td>Instruction TLB: 2-MByte or 4-MByte pages, fully associative, 7 entries</td>
        </tr>
        <tr>
          <td>56H</td>
          <td>TLB</td>
          <td>Data TLB0: 4 MByte pages, 4-way set associative, 16 entries</td>
        </tr>
        <tr>
          <td>57H</td>
          <td>TLB</td>
          <td>Data TLB0: 4 KByte pages, 4-way associative, 16 entries</td>
        </tr>
        <tr>
          <td>59H</td>
          <td>TLB</td>
          <td>Data TLB0: 4 KByte pages, fully associative, 16 entries</td>
        </tr>
        <tr>
          <td>5AH</td>
          <td>TLB</td>
          <td>Data TLB0: 2-MByte or 4 MByte pages, 4-way set associative, 32 entries</td>
        </tr>
        <tr>
          <td>5BH</td>
          <td>TLB</td>
          <td>Data TLB: 4 KByte and 4 MByte pages, 64 entries</td>
        </tr>
        <tr>
          <td>5CH</td>
          <td>TLB</td>
          <td>Data TLB: 4 KByte and 4 MByte pages,128 entries</td>
        </tr>
        <tr>
          <td>5DH</td>
          <td>TLB</td>
          <td>Data TLB: 4 KByte and 4 MByte pages,256 entries</td>
        </tr>
        <tr>
          <td>60H</td>
          <td>Cache</td>
          <td>1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>66H</td>
          <td>Cache</td>
          <td>1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>67H</td>
          <td>Cache</td>
          <td>1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>68H</td>
          <td>Cache</td>
          <td>1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>70H</td>
          <td>Cache</td>
          <td>Trace cache: 12 K-op, 8-way set associative</td>
        </tr>
        <tr>
          <td>71H</td>
          <td>Cache</td>
          <td>Trace cache: 16 K-op, 8-way set associative</td>
        </tr>
        <tr>
          <td>72H</td>
          <td>Cache</td>
          <td>Trace cache: 32 K-op, 8-way set associative</td>
        </tr>
        <tr>
          <td>78H</td>
          <td>Cache</td>
          <td>2nd-level cache: 1 MByte, 4-way set associative, 64byte line size</td>
        </tr>
        <tr>
          <td>79H</td>
          <td>Cache</td>
          <td>2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
      </table>
      <p>Table 3-17. Encoding of CPUID Leaf 2 Descriptors (Contd.)</p>
      <table>
        <tr>
          <th>Value</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>7AH</td>
          <td>Cache</td>
          <td>2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
        <tr>
          <td>7BH</td>
          <td>Cache</td>
          <td>2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
        <tr>
          <td>7CH</td>
          <td>Cache</td>
          <td>2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector</td>
        </tr>
        <tr>
          <td>7DH</td>
          <td>Cache</td>
          <td>2nd-level cache: 2 MByte, 8-way set associative, 64byte line size</td>
        </tr>
        <tr>
          <td>7FH</td>
          <td>Cache</td>
          <td>2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size</td>
        </tr>
        <tr>
          <td>80H</td>
          <td>Cache</td>
          <td>2nd-level cache: 512 KByte, 8-way set associative, 64-byte line size</td>
        </tr>
        <tr>
          <td>82H</td>
          <td>Cache</td>
          <td>2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>83H</td>
          <td>Cache</td>
          <td>2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>84H</td>
          <td>Cache</td>
          <td>2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>85H</td>
          <td>Cache</td>
          <td>2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size</td>
        </tr>
        <tr>
          <td>86H</td>
          <td>Cache</td>
          <td>2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>87H</td>
          <td>Cache</td>
          <td>2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>B0H</td>
          <td>TLB</td>
          <td>Instruction TLB: 4 KByte pages, 4-way set associative, 128 entries</td>
        </tr>
        <tr>
          <td>B1H</td>
          <td>TLB</td>
          <td>Instruction TLB: 2M pages, 4-way, 8 entries or 4M pages, 4-way, 4 entries</td>
        </tr>
        <tr>
          <td>B2H</td>
          <td>TLB</td>
          <td>Instruction TLB: 4KByte pages, 4-way set associative, 64 entries</td>
        </tr>
        <tr>
          <td>B3H</td>
          <td>TLB</td>
          <td>Data TLB: 4 KByte pages, 4-way set associative, 128 entries</td>
        </tr>
        <tr>
          <td>B4H</td>
          <td>TLB</td>
          <td>Data TLB1: 4 KByte pages, 4-way associative, 256 entries</td>
        </tr>
        <tr>
          <td>BAH</td>
          <td>TLB</td>
          <td>Data TLB1: 4 KByte pages, 4-way associative, 64 entries</td>
        </tr>
        <tr>
          <td>C0H</td>
          <td>TLB</td>
          <td>Data TLB: 4 KByte and 4 MByte pages, 4-way associative, 8 entries</td>
        </tr>
        <tr>
          <td>CAH</td>
          <td>STLB</td>
          <td>Shared 2nd-Level TLB: 4 KByte pages, 4-way associative, 512 entries</td>
        </tr>
        <tr>
          <td>E4H</td>
          <td>Cache</td>
          <td>3rd-level cache: 8 MByte, 16-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>EAH</td>
          <td>Cache</td>
          <td>3rd-level cache: 12MByte, 24-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>EBH</td>
          <td>Cache</td>
          <td>3rd-level cache: 18MByte, 24-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>ECH</td>
          <td>Cache</td>
          <td>3rd-level cache: 24MByte, 24-way set associative, 64 byte line size</td>
        </tr>
        <tr>
          <td>F0H</td>
          <td>Prefetch</td>
          <td>64-Byte prefetching</td>
        </tr>
        <tr>
          <td>F1H</td>
          <td>Prefetch</td>
          <td>128-Byte prefetching</td>
        </tr>
        <tr>
          <td>FFH</td>
          <td>General</td>
          <td>CPUID leaf 2 does not report cache descriptor information, use CPUID leaf 4 to query cache parameters</td>
        </tr>
      </table>
      <p>Example 3-1. Example of Cache and TLB Interpretation</p>
      <p>The first member of the family of Pentium 4 processors returns the following information about caches and TLBs when the CPUID executes with an input value of 2:</p>
      <p>EAX 66 5B 50 01H</p>
      <p>EBX 0H</p>
      <p>ECX 0H</p>
      <p>EDX 00 7A 70 00H</p>
      <p>Which means:</p>
      <ul>
        <li>The least-significant byte (byte 0) of register EAX is set to 01H. This indicates that CPUID needs to be executed once with an input value of 2 to retrieve complete information about caches and TLBs.</li>
        <li>The most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register contains valid 1-byte descriptors.</li>
        <li>Bytes 1, 2, and 3 of register EAX indicate that the processor has:</li>
      </ul>
      <ul>
        <li>50H - a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4MByte pages.</li>
        <li>5BH - a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages.</li>
        <li>66H - an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.</li>
      </ul>
      <ul>
        <li>The descriptors in registers EBX and ECX are valid, but contain NULL descriptors.</li>
        <li>Bytes 0, 1, 2, and 3 of register EDX indicate that the processor has:</li>
      </ul>
      <ul>
        <li>00H - NULL descriptor.</li>
        <li>70H - Trace cache: 12 K-op, 8-way set associative.</li>
        <li>7AH - a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size.</li>
        <li>00H - NULL descriptor.</li>
      </ul>
      <p>INPUT EAX = 04H: Returns Deterministic Cache Parameters for Each Level</p>
      <p>When CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns encoded data that describe a set of deterministic cache parameters (for the cache level associated with the input in ECX). Valid index values start from 0.</p>
      <p>Software can enumerate the deterministic cache parameters for each level of the cache hierarchy starting with an index value of 0, until the parameters report the value associated with the cache type field is 0. The architecturally defined fields reported by deterministic cache parameters are documented in "Information Returned by CPUID Instruction".</p>
      <p>This Cache Size in Bytes</p>
      <p>= (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1) = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (EXC + 1)</p>
      <p>The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores in a physical package. This information is constant for all valid index values. Software can query the raw data reported by executing CPUID with EAX=04H and ECX=0 and use it as part of the topology enumeration algorithm described in Chapter 8, "Multiple-Processor Management," in theIntel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.</p>
      <p>INPUT EAX = 05H: Returns MONITOR and MWAIT Features</p>
      <p>When CPUID executes with EAX set to 05H, the processor returns information about features available to MONITOR/MWAIT instructions. The MONITOR instruction is used for address-range monitoring in conjunction with MWAIT instruction. The MWAIT instruction optionally provides additional extensions for advanced power management. See "Information Returned by CPUID Instruction".</p>
      <p>INPUT EAX = 06H: Returns Thermal and Power Management Features</p>
      <p>When CPUID executes with EAX set to 06H, the processor returns information about thermal and power management features. See "Information Returned by CPUID Instruction".</p>
      <p>INPUT EAX = 09H: Returns Direct Cache Access Information</p>
      <p>When CPUID executes with EAX set to 09H, the processor returns information about Direct Cache Access capabilities. See "Information Returned by CPUID Instruction".</p>
      <p>INPUT EAX = 0AH: Returns Architectural Performance Monitoring Features</p>
      <p>When CPUID executes with EAX set to 0AH, the processor returns information about support for architectural performance monitoring capabilities. Architectural performance monitoring is supported if the version ID (see "Information Returned by CPUID Instruction") is greater thanPn 0. See "Information Returned by CPUID Instruction".</p>
      <p>For each version of architectural performance monitoring capability, software must enumerate this leaf to discover the programming facilities and the architectural performance events available in the processor. The details are described in Chapter20, "Introduction to Virtual-Machine Extensions," in theIntel®64 and IA-32 Architectures Software Developer's Manual, Volume 3B.</p>
      <p>INPUT EAX = 0BH: Returns Extended Topology Information</p>
      <p>When CPUID executes with EAX set to 0BH, the processor returns information about extended topology enumeration data. Software must detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf index supported by CPUID is &gt;= 0BH, and</p>
      <p>(b)CPUID.0BH:EBX[15:0] reports a non-zero value. See "Information Returned by CPUID Instruction".</p>
      <p>INPUT EAX = 0DH: Returns Processor Extended States Enumeration Information</p>
      <p>When CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the bit-vector representation of all processor state extensions that are supported in the processor and storage size requirements of the XSAVE/XRSTOR area. See "Information Returned by CPUID Instruction".</p>
      <p>When CPUID executes with EAX set to 0DH and ECX = n (n &gt; 1, and is a valid sub-leaf index), the processor returns information about the size and offset of each processor extended state save area within the XSAVE/XRSTOR area. See "Information Returned by CPUID Instruction".Software can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain size and offset information for each processor extended state save area:</p>
      <p>For i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI;</p>
      <p>METHODS FOR RETURNING BRANDING INFORMATION</p>
      <p>Use the following techniques to access branding information:</p>
      <ul>
        <li>Processor brand string method; this method also returns the processor's maximum operating frequency </li>
        <li>Processor brand index; this method uses a software supplied brand string table.</li>
      </ul>
      <p>These two methods are discussed in the following sections. For methods that are available in early processors, see Section: "Identification of Earlier IA-32 Processors" in Chapter 14 of the Intel®64 and IA-32 Architectures Software Developer's Manual,Volume 1.</p>
      <p>The Processor Brand String Method</p>
      <p>Figure 3-8 describes the algorithm used for detection of the brand string. Processorbrand identification software should execute this algorithm on all Intel 64 and IA-32 processors.</p>
      <p>This method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the maximum operating frequency of the processor to the EAX, EBX, ECX, and EDX registers.</p>
      <p>Figure 3-8. Determination of Support for the Processor Brand String</p>
      <p>How Brand Strings Work</p>
      <p>To use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input value, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL-terminated.</p>
      <p>Table 3-18 shows the brand string that is returned by the first processor in thePentium 4 processor family.</p>
      <p>Table 3-18. Processor Brand String Returned with Pentium 4 Processor</p>
      <table>
        <tr>
          <th>EAX Input Value</th>
          <th>Return Values</th>
          <th>ASCII Equivalent</th>
        </tr>
        <tr>
          <td>80000002H</td>
          <td>EAX = 20202020H EBX = 20202020H ECX = 20202020H EDX = 6E492020H</td>
          <td>" " "" "" "nI "</td>
        </tr>
        <tr>
          <td>80000003H</td>
          <td>EAX = 286C6574H EBX = 50202952H ECX = 69746E65H EDX = 52286D75H</td>
          <td>"(let" "P )R" "itne" "R(mu"</td>
        </tr>
        <tr>
          <td>80000004H</td>
          <td>EAX = 20342029H EBX = 20555043H ECX = 30303531H EDX = 007A484DH</td>
          <td>" 4 )" " UPC" "0051" "\0zHM"</td>
        </tr>
      </table>
      <p>Extracting the Maximum Processor Frequency from Brand Strings</p>
      <p>Figure 3-9 provides an algorithm which software can use to extract the maximumprocessor operating frequency from the processor brand string.</p>
      <p>NOTE</p>
      <p>When a frequency is given in a brand string, it is the maximum qualified frequency of the processor, not the frequency at which the processor is currently running.</p>
      <p>Figure 3-9. Algorithm for Extracting Maximum Processor Frequency</p>
      <p>The Processor Brand Index Method</p>
      <p>The brand index method (introduced with Pentium® III Xeon® processors) provides an entry point into a brand identification table that is maintained in memory by system software and is accessible from system- and user-level code. In this table, each brand index is associate with an ASCII brand identification string that identifies the official Intel family and model number of a processor.</p>
      <p>When CPUID executes with EAX set to 1, the processor returns a brand index to the low byte in EBX. Software can then use this index to locate the brand identification string for the processor in the brand identification table. The first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do not support the brand identification feature. Starting with processor signature family ID = 0FH, model = 03H, brand index method is no longer supported. Use brand string method instead.</p>
      <p>Table 3-19 shows brand indices that have identification strings associated with them.</p>
      <p>Table 3-19. Mapping of Brand Indices; and
        Intel 64 and IA-32 Processor Brand Strings
      </p>
      <table>
        <tr>
          <td>Brand Index</td>
          <td>Brand String</td>
        </tr>
        <tr>
          <td>00H</td>
          <td>This processor does not support the brand identification feature</td>
        </tr>
        <tr>
          <td>01H</td>
          <td>Intel(R) Celeron(R) processor1</td>
        </tr>
        <tr>
          <td>02H</td>
          <td>Intel(R) Pentium(R) III processor1</td>
        </tr>
        <tr>
          <td>03H</td>
          <td>Intel(R) Pentium(R) III Xeon(R) processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor</td>
        </tr>
        <tr>
          <td>04H</td>
          <td>Intel(R) Pentium(R) III processor</td>
        </tr>
        <tr>
          <td>06H</td>
          <td>Mobile Intel(R) Pentium(R) III processor-M</td>
        </tr>
        <tr>
          <td>07H</td>
          <td>Mobile Intel(R) Celeron(R) processor1</td>
        </tr>
        <tr>
          <td>08H</td>
          <td>Intel(R) Pentium(R) 4 processor</td>
        </tr>
        <tr>
          <td>09H</td>
          <td>Intel(R) Pentium(R) 4 processor</td>
        </tr>
        <tr>
          <td>0AH</td>
          <td>Intel(R) Celeron(R) processor1</td>
        </tr>
        <tr>
          <td>0BH</td>
          <td>Intel(R) Xeon(R) processor; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor MP</td>
        </tr>
        <tr>
          <td>0CH</td>
          <td>Intel(R) Xeon(R) processor MP</td>
        </tr>
        <tr>
          <td>0EH</td>
          <td>Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(R) processor</td>
        </tr>
        <tr>
          <td>0FH</td>
          <td>Mobile Intel(R) Celeron(R) processor1</td>
        </tr>
        <tr>
          <td>11H</td>
          <td>Mobile Genuine Intel(R) processor</td>
        </tr>
        <tr>
          <td>12H</td>
          <td>Intel(R) Celeron(R) M processor</td>
        </tr>
        <tr>
          <td>13H</td>
          <td>Mobile Intel(R) Celeron(R) processor1</td>
        </tr>
        <tr>
          <td>14H</td>
          <td>Intel(R) Celeron(R) processor</td>
        </tr>
        <tr>
          <td>15H</td>
          <td>Mobile Genuine Intel(R) processor</td>
        </tr>
        <tr>
          <td>16H</td>
          <td>Intel(R) Pentium(R) M processor</td>
        </tr>
        <tr>
          <td>17H</td>
          <td>Mobile Intel(R) Celeron(R) processor1</td>
        </tr>
        <tr>
          <td>18H - 0FFH</td>
          <td>RESERVED</td>
        </tr>
      </table>
      <p>NOTES:</p>
      <p>1. Indicates versions of these processors that were introduced after the Pentium III</p>
